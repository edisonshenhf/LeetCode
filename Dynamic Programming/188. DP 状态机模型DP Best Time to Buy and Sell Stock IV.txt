//疑问1:为什么不能用Integer.MIN_VALUE 要用(int) 1e8?

// f(i,j) 已经过了i天,且转了j圈的最大收益
// g(i,j) 已经过了i天，且正在转j圈的最大收益
//状态转移dp

//f(i,j)=Math.max(f(i-1,j)      ,      g(i-1,j)+wi)
//               当天不交易            当天不交易
//               昨天也没交易          昨天正在卖出

//g(i,j)=Math.max(g(i-1,j))     ,      f(i-1,j-1)-wi)
//               当天不动              当天不动
//               昨天买入或者不动      昨天买入


//初始边界f(0,0) 答案为所有f(i,j)中取max

class Solution {
    public int maxProfit(int k, int[] prices) {
        int INF = (int) 1e8;
        int res = 0;
        int n = prices.length;
        if(k>=n/2){
            for(int i=0;i<n-1;i++){
                if(prices[i+1]>prices[i]) res+=prices[i+1]-prices[i];
            }
            return res;
        }
        int[][] f= new int[n+1][k+1];
        int[][] g=  new int[n+1][k+1];
        for(int i=0;i<=n;i++){
            Arrays.fill(f[i],-INF);
            Arrays.fill(g[i],-INF);
        }
        f[0][0]=0;
        for (int i = 1; i <= n; i ++ ){
            for (int j = 0; j <= k; j ++ ) {
                f[i][j] = Math.max(f[i - 1][j], g[i - 1][j] + prices[i - 1]);
                g[i][j]=g[i-1][j];
                if(j>0){
                    g[i][j] = Math.max(g[i][j], f[i - 1][j - 1] - prices[i - 1]);
                }
                res = Math.max(res, f[i][j]);
            }
        }
        return res;
    }
}