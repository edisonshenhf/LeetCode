//迭代的归并排序
//O(nlogn)的time complexity O(1)的 extra space
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode sortList(ListNode head) {
        int n = 0;
        ListNode temp = head;
        while(temp!=null){
            temp=temp.next;
            n++;
        }
        for(int i=1;i<=n;i*=2){
            ListNode dummy = new ListNode(-1);
            ListNode cur = dummy;
            for(int j=1;j<=n;j+=i*2){
                ListNode p = head;
                ListNode q = p;
                for(int k=0;k<i&&q!=null;k++){
                    q=q.next;
                }
                ListNode o = q;
                for(int k=0;k<i&&o!=null;k++){
                    o=o.next;
                }
                head=o;
                int l =0;
                int r = 0;
                while(l<i&&r<i&&q!=null&&p!=null){
                    if(p.val<=q.val){
                        cur=cur.next=p;
                        p=p.next;
                        l++;
                    }else{
                        cur=cur.next=q;
                        q=q.next;
                        r++;
                    }
                }
                while(l<i&&p!=null){
                    cur=cur.next=p;
                    p=p.next;
                    l++;
                }
                while(r<i&&q!=null){
                    cur=cur.next=q;
                    q=q.next;
                    r++;
                }
            }
            cur.next=null;
            head=dummy.next;
        }
        return head;
    }
}


//递归的归并排序
//O(nlogn)的time complexity O(nlogn)的 extra space

/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode sortList(ListNode head) {
        if(head==null||head.next==null) return head;
        ListNode fast = head;
        ListNode slow = head;
        ListNode ed = slow;
        while(fast!=null&&fast.next!=null){
            fast=fast.next.next;
            ed=slow;
            slow=slow.next;
        }
        ed.next=null;
        ListNode left = sortList(head);
        ListNode right = sortList(slow);
        return merge(left,right);
    }

    ListNode merge(ListNode left,ListNode right){
        ListNode dummy = new ListNode(-1);
        ListNode cur = dummy;
        while(left!=null&&right!=null){
            if(left.val<=right.val){
                cur=cur.next=left;
                left=left.next;
            }else{
                cur=cur.next=right;
                right=right.next;
            }
        }
        if(left!=null) cur.next=left;
        else cur.next= right;
        return dummy.next;
    }
}