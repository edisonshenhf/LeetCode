//贪心 Greedy
class Solution {
    public int canCompleteCircuit(int[] gas, int[] cost) {
        int n = gas.length;
        for(int i =0,j=0;i<n;){
            int left = 0;
            for(j=0;j<n;j++){
                left+=gas[(i+j)%n]-cost[(i+j)%n];
                if(left<0) break;
            }
            if(j==n) return i;
            i=i+j+1;
        }
        return -1;
    }
}

//单调队列用途
//1.求窗口内的极值(最大值 最小值)
//2.求这下一个比这个小的数

class Solution {
    public int canCompleteCircuit(int[] gas, int[] cost) {
        int n =gas.length;
        int[] s =new int[2*n+2];
        int[] q = new int[n+10];
        for(int i=1;i<=n;i++){
            s[i]=s[i+n]=gas[i-1]-cost[i-1];
        }
        for(int i=1;i<=2*n;i++){
            s[i]+=s[i-1];
        }
        int hh=0, tt=-1;
        for(int i = n * 2;i >= 1;i --)
        {
            if(hh <= tt && q[hh] > i + n - 1) hh ++;//如果队头元素的i已经超出滑动窗口 弹出hh
            while(hh <= tt && s[q[tt]] >= s[i]) tt --;//如果队尾元素比这个数大 队尾元素弹出
            q[++ tt] = i;//插入元素

            if(i <= n && s[q[hh]] - s[i+n-1] >= 0) return i - 1;//如果队列中最小的数都比初始值大 则可以完成转圈
        }
        return -1;
    }
}