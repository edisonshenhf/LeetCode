//基于快速排序
//快速排序的原理是选定中位数后把大于中位数的排到右边，小于中位数的排到左边
//分别再快排左右两段 所以是nlogn的时间复杂的
//快速筛选是基于快速排序 例如要求kth个最大的数 如果这个数在左半边那就只需要快排左半边就行 右半边直接舍弃
//时间复杂度为o2n

class Solution {
    public int findKthLargest(int[] nums, int k) {
        return quickSort(nums,0,nums.length-1,k-1);
    }
    public int quickSort(int[] nums,int l,int r,int k){
        if(l==r) return nums[k];
        int x = nums[l+r>>1];
        int i = l-1;
        int j = r+1;
        while(i<j){
            while(nums[++i]>x);
            while(nums[--j]<x);
            if(i<j){
                int temp = nums[i];
                nums[i]=nums[j];
                nums[j]=temp;
            }
        }
        if(k<=j) return quickSort(nums,l,j,k);
        else return quickSort(nums,j+1,r,k);
    }
}