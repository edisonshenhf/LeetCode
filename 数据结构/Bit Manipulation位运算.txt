//位运算可以避免或者减少在一个数据结构上需要进行循环的次数，并且可以成倍的提升效率，
//因为位运算是并行处理的，但是缺点是位运算的代码比较难以编写及维护。
//由于在计算机中，二进制的存储形式为补码形式，事实上，计算机中有且仅有补码一种码，
//而我们所说的原码、反码都是所定义出的为了与补码形成转换关系的格式。
//正数的原码、反码、补码都是其本身，负数的原码最高位符号位为1，反码除符号位外取反，补码在反码基础上加一得到。
//例如，正整数5的原码、反码、补码都为0x00000101，对5取反就有0x11111010，
//由于这是补码表示，转换为反码是0x11111001，转换为原码是0x10000110，即-6为对5取反后的值。
//很好的解释:
//https://leetcode.com/problems/sum-of-two-integers/solutions/84278/A-summary:-how-to-use-bit-manipulation-to-solve-problems-easily-and-efficiently/

And:&(与运算) 		Or:|(或运算)		XOr:^(异或运算)		Not:~(取反运算)
操作数1 操作数2 Result	操作数1 操作数2 Result	操作数1	操作数2	Result	操作数1	Result
   0       0      0	   0       0      1	   0       0       0	   0	   1
   1       0      0	   1       0      1	   0       1       1	   1	   0
   0       1      0	   0       1      1	   1       0       1
   1       1      1	   1       1      1        1       1       0


